\chapter{Methoden}
\label{sec:Chapter2}
\section{Bloom Filter}
\label{sec:Sec1.2}

Alle diese Methoden basieren auf sogenannten Bloomfiltern.
Hierbei handelt es sich um eine  Technik um festzustellen, ob bestimmte Daten in einem Datensatz vorhanden sind oder nicht.
Sie bestehen aus einem mit Nullen vorinitialisiertem m Bit langen Array und k Hashfunktionen, welche auf die Positionen des Arrays abbilden.

Zur Initialisierung werden auf jedes Element des Datensatzes alle k Hashfunktionen angewendet.
Die zur Ausgabe der Hashfunktionen korrespondierenden Bits im Array werden darauf hin auf Eins gesetzt.

Soll für ein Datenelement geprüft werden, ob dieses Teil des Datensatzes ist, werden  alle Hashfunktionen auf dieses angewendet.\\
Nur wenn alle Positionen im Array an den korrespondierenden Punkten der Ausgabe dem Wert Eins entsprechen wird angenommen das sich das Element im Datensatz befindet.

Diese Überprüfung ist jedoch nicht resistent gegenüber Falsch Positiven Ergebnissen, da diese Positionen auch durch mehrere 

\section{Kryptosysteme}
\label{sec:Sec1.3}

\subsection{Homomorphie}
Homomorphie bezeichnet eine Eigenschaft von Kryptosystemen. 
Ein Kryptosystem ist genau dann homomorph gegenüber einer mathematischen Operation, wenn Berechnungen im Ciphertext mit dieser Operation denen im KLartext entsprechen.

\subsection{Elgamal}
\label{sec:Sec1.3.1}

Bei Elgamal handelt es sich um ein im Jahr 1985 vom Kryptologen Taher Elgamal entwickeltes Public-Key-Verschlüsselungsverfahren. Elgamal ist eine Erweiterung des Diffie-Hellmann
Schlüsselaustausches.

\textbf{Verfahren}\\

Zunächst wählt der Client eine endliche zyklische Gruppe Z der Ordnung q mit einem Generator g.
\begin{itemize}	
	\item Secrect key: Der Client wählt eine zufällige Zahl $a<q$ mit dem $GGT(a,q) = 1$. Dies ist der Secret key
	\item Public Key: Der public key ist dann $P = g\textsuperscript{a} $	
\end{itemize}

Sei $m \in Z\textsubscript{q}$ die zu versendende Nachricht. Dann wählt der Server eine zufällige Zahl $r<q$ mit dem $GGT(r,q) = 1$. Nun berechnet sich $c\textsubscript{1} = g\textsuperscript{r}$ sowie $c\textsubscript{2} =P \textsuperscript{r} *m$. Der Ciphertext besteht so aus $C = (c\textsubscript{1},c\textsubscript{2})$.

Zur Entschlüsselung wird $\Sigma = c_{1}^{-q} * c_{2} brechnet.$

\textbf{Homomorphie}\\
Elgamal ist homomorph gegenüber der Multiplikation
$$ E(m \textsubscript{1} * m \textsubscript{2}) = (E(m \textsubscript{1}) * E(m \textsubscript{2}))$$

\textbf{Sicherheit}\\
Elgamal ist IND-CPA sicher, falls das



Dann gibt es einen Algorithmus, der in polyn. Zeit DH-Schlussel gab von zufalligen Gruppenelementen unterscheidet.
Widerspruch:
Nach Annahme gibt es keinen effizienten
Algorithmus zum Entscheiden von DH-Schlusselngab.
Daher kann es auch keinen polynomiellen Angreifer A geben.



\subsection{Pailier}
\label{sec:Sec1.3.2}

\textbf{Verfahren}\\
\\
\textit{Schlüsselerzeugung:}\\
Das Schlüsselpaar wird folgendermaßen generiert:
Der Client wählt zwei Primzahlen p,q , mit ggt(pq, (p-1)(q-1))= 0. Des weiteren wird der Generator g so gewählt, sodass $ g \in (\mathbb{Z}/ n^{2} \mathbb{Z}) $ und$ n $ die Ordnung von g teilt.
Das Schlüsselpaar wird dann folgendermaßen gebildet.
\begin{itemize}	
	\item Secrect key: $ \lambda = kgV(p-1, q-1) $
	\item Public Key: $(n,g)$	
\end{itemize}

\textit{Verschlüsselung:}\\
Zur Verschlüsselung einer Nachricht $ m \in \mathbb{Z} $ wählt der Client zunächst eine Zufalls Zahl $ r $ wobei $ 0 \leq r \leq n $\\
Dann berechnet sich der Ciphertext $ c = g^{m}*r^{n} \mod\ n^{2} $\\
\textit{Entschlüsselung:}\\
Der Plaintext kann folgendermaßen berechnet werden: $ m = L(c^{\lambda} \mod n^{2}) * \mu mod n $\\
\\
\textbf{Homomorphie:}\\
Paillier ist homomorph gegenüber der Addition.

$$ E(m \textsubscript{1} + m \textsubscript{2}) = (E(m \textsubscript{1}) + E(m \textsubscript{2}))$$

\textbf{Sicherheit}\\
 

\subsection{Goldwasser-micali}
\label{sec:Sec1.3.3}

\textbf{Verfahren:}\\

\textit{Schlüsselerzeugung:}\\
Zunächst generiert der Client zwei Primzahlen $ p,q  $ und berechnet dann den RSA Modulus $ N = pq $. Des weiteren bestimmt er einen Nichtrest u und das Jakobi Symbol $ (\dfrac{y}{n})=1 $, sodass das Legendre Symbol $ (\dfrac{y}{q} = \dfrac{y}{p} = -1) $

Das Schlüsselpaar wird dann folgendermaßen gebildet.
\begin{itemize}	
	\item Secrect key: $ (p,q) $
	\item Public Key: $(n,u)$	
\end{itemize}
\textit{Verschlüsselung:}\\
Zur Verschlüsselung einer Nachricht $ m \in (0,1) $ wählt der Client zunächst eine Zufallszahl $ r\in \mathbb{Z} $.
\textit{Entschlüsselung:}\\
\textbf{Homomorphie:}\\

Paillier ist homomorph gegenüber der Addition.

\textbf{Sicherheit}\\

\section{Implementierte Algorithmen}

\subsection{Algorithmus 1 - Elgamal}

Dieser Algorithmus wurde zunächst im ... veröffentlicht. Es wurden Algorithmen für unterschiedliche Konstellationen postuliert. 

Der Client erstellt zu Beginn einen Boomfilter seiner Daten. Dabei wird jedes Datenelement einzeln 
Zur Verschlüsselung wählt der Client zunächst public und secret key nach elgamal.
Daraufhin wird jedes Bit des Bloomfilter Arrays einzeln verschlüsselt.
Hierzu werden die zu sendende Nachrichten so gewählt das $m = g^BF[i]$
Dies führt dazu, dass $ m $ an Stellen an welchen der Bloomfilter $ BF_Client = 0 $  dem Wert 1  entspricht und an den Stellen, an denen $ BF_Client = 1 $ dem Generator g.

\[
S\textsubscript{i} = pk^{r_{i}} \ * \ \left\{
\begin{array}{ll}
g^{0} = 1 \ bei \  BF\textsubscript{1}[i]=1\\
g^{1} = g \ bei \ BF\textsubscript{1}[i]=0\\
\end{array}
\right.
\]

Diese Nachricht wird dann nach Elgamal verschlüsselt. Der Ciphertext entspricht dann:
$$(R_i, S_i) = (g \textsuperscript{r\textsubscript{i}} , pk\textsuperscript{r\textsubscript{i}} * g\textsuperscript{1-BF\textsubscript{1}[i]})$$

Der Ciphertext wird dann zusammen mit dem public key und den Bloomfilter Parametern an den Server übermittelt.
Dieser erstellt nun seinerseits einen Bloomfilter mit den Einträgen seines Datensatzes unter Berücksichtigung der Parameter des Clients. 

Für alle Indices an welchen $BF_Server = 0$ werden die Elemente des Ciphertextes des Clients $R_i$ und $S_i$ aufmultipliziert.
Dies ist aufgrund der Homomorphie Eigenschaft von Elgamal ohne Datenverlust möglich.

Daraufhin selektiert dieser alle Indexes von Einträgen seines Bloomfilters. Indices 
Für jeden dieser Indices wird daraufhin der entsprechende Eintrag im Ciphertexts des Clients 
Aufmultiplikation  von $R_i$ bzw $S_i$ an jenen Stellen, an welchen $BF_2 = 0$ ist.

$$ V = (g^{s + r_{i_{1}} + r_{i_{2}} + \ ...\ +r_{i_{k}}})$$

\[
W =\left\{
\begin{array}{ll}
pk^{s + r_{i_{1}} + r_{i_{2}} + \ ...\ +r_{i_{l}}}*1 \ falls \ BF_{1} = 1,BF_{2} = 0 \\
pk^{s + r_{i_{1}} + r_{i_{2}} + \ ...\ +r_{i_{m}}}*g^{x} \ falls \ BF_{1} = BF_{2} = 0\\
\end{array}
\right.
\]

Die Ergebnisse werden nun mit $ g \textsuperscript{s}  $ bzw. $ pk \textsuperscript{s} $ rerandomisiert :
$$ V = (g \textsuperscript{s} * \Pi_{i:BF_{2}[i] = 0} R_{i} )$$
$$ W = (pk \textsuperscript{s} * \Pi_{i:BF_{2}[i] = 0} S_{i} )$$ \\
$ V $ und $ W $ werden nun zurück an den Client gesendet, welcher nun die Elgamal Entschlüsselung auf diese anwendet:
$$\Sigma = W * V^{-sk}$$

Da $pk$ = $g^{sk}$, ergibt sich folgende Gleichung:
	
$$\Sigma = (g^{sk * s + r_{i_{1}} + r_{i_{2}} + \ ...\ +r_{i_{k}}} \ * \ g^{-sk * s + r_{i_{1}} + r_{i_{2}} + \ ...\ +r_{i_{k}}} \ * \ g^z) $$


Nach dem Kürzen erhält man:
$$\Sigma = g^x$$

$ z $ entspricht hierbei der Anzahl  an Positionen an denen sowohl der Client als auch der Server einen Nulleintag in ihren Bloomfiltern haben.

Der approximierte Betrag der im Bloomfilter gespeicherten Elemente errechnet sich dann durch:

$$ |X| = \frac{ln( \frac{z}{m})}{k* \ ln(1- \frac{1}{m})}$$



\subsection{Algorithmus 2 - Paillier}
\label{sec:Sec2.3}




\subsection{Algorithmus 3 - Goldwasser-Micali}
\label{sec:Sec2.4}






