\documentclass{beamer}
%
% Choose how your presentation looks.
%
% For more themes, color themes and font themes, see:
% http://deic.uab.es/~iblanes/beamer_gallery/index_by_theme.html
%
\mode<presentation>
{
   
  \usetheme{IMI} 
  %\usetheme{default}      % or try Darmstadt, Madrid, Warsaw, ...
  \usecolortheme{default} % or try albatross, beaver, crane, ...
  \usefonttheme{default}  % or try serif, structurebold, ...
  \setbeamertemplate{navigation symbols}{}
  \setbeamertemplate{caption}[numbered]

} 

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{enumitem}
\newlist{arrowlist}{itemize}{1}
\setlist[arrowlist]{label=$\Rightarrow$}
\usepackage{tikz}
\tikzset{
	every overlay node/.style={
		%draw=black,fill=white,rounded corners,
		anchor=north west,
	},
}
% Usage:
% \tikzoverlay at (-1cm,-5cm) {content};
% or
% \tikzoverlay[text width=5cm] at (-1cm,-5cm) {content};
\def\tikzoverlay{%
	\tikz[baseline,overlay]\node[every overlay node]
}%

\title[Privatly computing Set-Intersection]{Privatly computing Set-Intersection using Bloom Filters}
\author{Niklas Jobst}
\institute{TCS - Universität zu Lübeck}
\date{\today}

\begin{document}


% Uncomment these lines for an automatically generated outline.
%\begin{frame}{Outline}
%  \tableofcontents
%\end{frame}
\section{Einleitung}
\begin{frame}{Formel}
	$$ |X| = \frac{ln( \frac{z}{m})}{k* \ ln(1- \frac{1}{m})}$$
	
	\begin{arrowlist}
		\item Basiert auf Berechnung Anzahl von Nullen in einem Bloomfilter:
		\item 	$ z = m*(1 -\frac{1}{m})\textsuperscript{k*X}$ 
	\end{arrowlist}

\end{frame}

\section{Algorithmus}


\begin{frame}{Algorithmus basierend auf Elgamal}
	\footnotesize
		\vskip 0.3cm
	\tikzoverlay (n1) at (-0.5cm,3cm) {
		\begin{minipage}{0.45\textwidth}
			\begin{block}{\textbf{Client} }
			\begin{arrowlist}
				\item Erstellt Bloom Filter ihrer Daten
				\item Verschlüsselt jede Stelle ihres Bloom Filters mittels ElGamal

			\end{arrowlist}
				\quad  \ \ $(R_i, S_i)=(g \textsuperscript{r\textsubscript{i}},pk\textsuperscript{r\textsubscript{i}}*g\textsuperscript{1-BF\textsubscript{1}[i]})$
			\end{block}
		\end{minipage}
	};
	
	\tikzoverlay (n2) at (6.7cm,3.5cm) {
		\begin{minipage}{0.45\textwidth}
			\begin{block}{\textbf{Server}}
			\begin{arrowlist}

				\item Erstellt Bloom Filter seiner Daten
				\item Selektiert jene Stellen Stellen in seinem BF die den Eintrag null besitzen.
				\item Multipliziert an diesen Stellen die Werte des Ciphertextes von Alice auf 
				\item Rerandomisiert die entstandenen Ergebnisse
				\quad  \ \	$$ V = (g \textsuperscript{s} * \Pi_{i:BF_{2}[i] = 0} R_{i} )$$
					$$ W = (pk \textsuperscript{s} * \Pi_{i:BF_{2}[i] = 0} S_{i} )$$ \\

			\end{arrowlist}
			\end{block}
		\end{minipage}
	};
	
	\tikzoverlay (n3) at (-0.5cm,0cm) {
		\begin{minipage}{0.45\textwidth}
			\begin{block}{}
						\begin{arrowlist}
							\item Alice entschlüsselt mit sk Ciphertext von Bob
							\item Bestimmt Anzahl der Einträge  an denen beide Bloom Filter null sind
							\item Berechnet die Set-Union der BF
						\end{arrowlist}
			\end{block}
		\end{minipage}
	};
	
	\begin{tikzpicture}[overlay]

	\draw[->,>=latex, line width=0.1cm] (4.8, 1)--(6.9, 1) node[above left] { $ \ [pk, (R_i, S_i)] \ \ $};
	\draw[->,>=latex, line width=0.1cm] (6.9, -1)--(4.8, -1) node[above right] {  $ \ \ (V,W) \ \ $};

	
	\end{tikzpicture}
	
	
\end{frame}

\begin{frame}{Paillier - Verfahren}

	\textbf{Schlüsselerzeugung:}\\
	
	
	Das Schlüsselpaar wird folgendermaßen generiert:
	Der Client wählt zwei Primzahlen p,q , mit ggt(pq, (p-1)(q-1))= 0. Des weiteren wird der Generator g so gewählt, sodass $ g \in (\mathbb{Z}/ n^{2} \mathbb{Z}) $ und$ n $ die Ordnung von g teilt.
	Das Schlüsselpaar wird dann folgendermaßen gebildet.
	\begin{itemize}	
		\item Secrect key: $ \lambda = kgV(p-1, q-1) $
		\item Public Key: $(n,g)$	
	\end{itemize}
	
	

\end{frame}

\begin{frame}
		\textbf{Verschlüsselung:}\\
		
		
		Zur Verschlüsselung einer Nachricht $ m \in \mathbb{Z} $ wählt der Client zunächst eine Zufalls Zahl $ r $ wobei $ 0 \leq r \leq n $
		Dann berechnet sich der Ciphertext $ c = g^{m}*r^{n} \mod\ n^{2} $\
		\newline
		\textbf{Entschlüsselung:}\\
		Der Plaintext kann folgendermaßen berechnet werden: $ m = L(c^{\lambda} \mod n^{2}) * \mu mod n $
		\newline
		\textbf{Homomorphie:}\\
		Paillier ist homomorph gegenüber der Addition.
		
		$$ E(m \textsubscript{1} + m \textsubscript{2}) = (E(m \textsubscript{1}) + E(m \textsubscript{2}))$$
\end{frame}

\begin{frame}{Algorithmus basierend auf Paillier}
	\footnotesize
	\vskip 0.3cm
	\tikzoverlay (n1) at (-0.5cm,3cm) {
		\begin{minipage}{0.45\textwidth}
			\begin{block}{\textbf{Client} }
				\begin{arrowlist}
						\item Erstellt Bloom Filter ihrer Daten
						\item Invertiert jede Stelle des Bloomfilters.
						\item Verschlüsselt jede Stelle ihres Bloomfilters mittels Paillier
						
					\end{arrowlist}
					\quad  \ \ $c =(g^{m}*r^{n}) mod n^{2} $
			\end{block}
		\end{minipage}
	};
	
	\tikzoverlay (n2) at (6.7cm,3.5cm) {
		\begin{minipage}{0.45\textwidth}
			\begin{block}{\textbf{Server}}
				\begin{arrowlist}
					
						\item Erstellt für jedes Element des Datensatzes einen Bloomfilter seiner Daten
						\item Selektiert in jedem Blommfilter jene Stellen die den Eintrag Eins besitzen.
						\item Addiert an diesen Stellen die Werte des Ciphertextes des Clients auf 
						\item Rerandomisiert die entstandenen Ergebnisse mit verschlüsselter Null
						\quad  \ \	$$ Rerand c_{j} = (cj * encrypt_{pailier}(0) )$$

					
				\end{arrowlist}
			\end{block}
		\end{minipage}
	};
	
	\tikzoverlay (n3) at (-0.5cm,0cm) {
		\begin{minipage}{0.45\textwidth}
			\begin{block}{}
				\begin{arrowlist}
					\item Alice entschlüsselt mit sk Ciphertexte von Bob
					\item Bestimmt Anzahl der Einträge  an denen beide Bloom Filter null sind
					\item Berechnet die Set-Union der BF
				\end{arrowlist}
			\end{block}
		\end{minipage}
	};
	
	\begin{tikzpicture}[overlay]
	
	\draw[->,>=latex, line width=0.1cm] (4.8, 1)--(6.9, 1) node[above left] { $  [pk, c] \ \ \ \ $};
	\draw[->,>=latex, line width=0.1cm] (6.9, -1)--(4.8, -1) node[above right] {  $ \ \ rerand(c_{1-j}) \ \ $};
	
	
	\end{tikzpicture}
	
	
\end{frame}

\begin{frame}{Ergebnisse }

 \begin{table}[h]
	\begin{tabular}{c|c|c|c|c}
		Überschneidung&14000&7500&5000&2000\\
		\hline
		Runtime (sec)& 221&247&211&222\\
		Abw. zur Überschn.& 0.01\%& 3.3\%&8.8\%&36.8\%\\
			 		
	\end{tabular}
	\caption{Hashfunktionen : 14, Anzahl Bloomfilter Bits:3029660, Größe der Datensätze: 15000 SNPs }
	\label{tab:meinetabelle1}
\end{table}
\begin{table}[h]
			 	
	\begin{tabular}{c|c|c|c|c}
	    Array& 1442696&1009887&577079&144270\\
	    \hline
		Runtime (sec)& 108&83&47&11\\
		Abweichung&4\%&6\%&13\%&51\%\\

			 		
	\end{tabular}
	\caption{Datensatz 1000 SNPs, Überschneidung 100, Hashfunktionen: 10 }
	\label{tab:meinetabelle2}
\end{table}
\end{frame}			 



\end{document}
